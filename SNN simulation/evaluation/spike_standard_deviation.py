"""
This code is for countering the spikes generated by every neuron. 
The spike records are loaded from the '../result' folder copied from the spike record in the code generation mdoe.
"""
"""
on 22th May 
by xiaoquinNUDT
version 0.0
"""
"""
test: no
"""
"""
optimazation record:
"""
##-----------------------------------------------------------------------------------------
import numpy as np
# np.fromfile() np.where() np.argsort() np.zeros() np.sum()
import matplotlib.pyplot as plt
# plt.figure() plt.title() plt.plot()
import sys
# sys.argv[]
##-----------------------------------------------------------------------------------------
simulation_name = raw_input('Simulation name: ')
num_example = int(raw_input('Number of examples per iteration: '))
population_OUT = int(raw_input('Population of OUT: '))
number_iteration = int(raw_input('Number of iterations: '))
start_iteration = int(raw_input('Start iteration: '))
simulation_folder = 'simulation_archive/' + simulation_name + '/' 

count_interval = 2000 
time_per_example = 0.5
count_interval_time = count_interval * time_per_example

num_count = int(num_example / count_interval)
num_point = num_count * number_iteration
spike_standard_deviation = np.zeros(num_point, dtype = float)

for i in xrange(number_iteration):
    spike_counter = np.zeros((num_count, population_OUT))
    passed_time_interval = count_interval_time # the first time interval
    iteration_folder = simulation_folder + 'iteration_' + str(i) + '/' 
    path_spike_record = iteration_folder + 'result/' # relative to the location of talent_run.sh
    spike_index_path_name = path_spike_record + 'dynamic_array_spikemonitor_i_'
    spike_time_path_name = path_spike_record + 'dynamic_array_spikemonitor_t_'
    spike_monitor_index = np.fromfile(spike_index_path_name, dtype = np.int32, count = -1, sep = "" )
    spike_monitor_time = np.fromfile(spike_time_path_name, dtype = np.float64, count = -1, sep = "")
    print('firing rate of per neuron for one example:' + str(float(len(spike_monitor_index))/population_OUT/num_example))
    spike_counter_one = np.zeros(population_OUT)
    number_count = 0
    for j, item in enumerate(spike_monitor_time):
        if item > passed_time_interval:
            number_count = int(item / count_interval_time) - 1
            spike_counter[number_count, :] = spike_counter_one 
            spike_counter_one = np.zeros(population_OUT)
            passed_time_interval += count_interval_time
        spike_counter_one[spike_monitor_index[j]] += 1
    number_count = num_count - 1
    spike_counter[number_count, :] = spike_counter_one 

    spike_average = np.sum(spike_counter, axis = 1) / population_OUT
    standard_deviation = np.sqrt(np.sum(np.square(spike_counter - spike_average.reshape(num_count, 1)), axis = 1) / population_OUT)
    spike_standard_deviation[i * num_count : (i+1) * num_count] = standard_deviation
    

print('average standard_deviation: ' + str(np.mean(spike_standard_deviation)))
np.save(simulation_folder + '/spike_standard_deviation.npy', spike_standard_deviation)

plt.figure(0)
x = np.arange(num_point)
plt.plot(x, spike_standard_deviation)
plt.ioff()
plt.show()
