"""
This code is for countering the spikes generated by every neuron. 
The spike records are loaded from the '../result' folder copied from the spike record in the code generation mdoe.
"""
"""
on 22th May 
by xiaoquinNUDT
version 0.0
"""
"""
test: no
"""
"""
optimazation record:
"""
##-----------------------------------------------------------------------------------------
import numpy as np
# np.fromfile() np.where() np.argsort() np.zeros() np.sum()
import matplotlib.pyplot as plt
# plt.figure() plt.title() plt.plot()
import sys
# sys.argv[]
##-----------------------------------------------------------------------------------------
num_example = int(sys.argv[1])
population_OUT = int(sys.argv[2])
archive_folder = str(sys.argv[3])
number_iteration = int(sys.argv[4])
iteration_folder = archive_folder + '/iteration_' + str(number_iteration) 
count_interval = 100 
path_spike_record = iteration_folder + '/result' # relative to the location of talent_run.sh
num_count = int(num_example / count_interval)
time_step = range(0, num_count) 
time_per_example = 0.5
spike_counter = np.zeros((num_count, population_OUT))
count_interval_time = count_interval * time_per_example
passed_time_interval = count_interval * time_per_example # the first time interval

spike_index_path_name = path_spike_record + '/dynamic_array_spikemonitor_i_'
spike_time_path_name = path_spike_record + '/dynamic_array_spikemonitor_t_'
spike_monitor_index = np.fromfile(spike_index_path_name, dtype = np.int32, count = -1, sep = "" )
spike_monitor_time = np.fromfile(spike_time_path_name, dtype = np.float64, count = -1, sep = "")
if len(spike_monitor_index) != len(spike_monitor_time):
    raise Exception('Spike records may not read properly!')
print('firing rate of per neuron for one example:' + str(float(len(spike_monitor_index))/population_OUT/num_example))
spike_counter_one = np.zeros(population_OUT)
number_count = 0
for j, item in enumerate(spike_monitor_time):
    if item > passed_time_interval:
        number_count = int(item / count_interval_time) - 1
        spike_counter[number_count, :] = spike_counter_one 
        spike_counter_one = np.zeros(population_OUT)
        passed_time_interval += count_interval_time
    spike_counter_one[spike_monitor_index[j]] += 1
spike_average = np.sum(spike_counter, axis = 1) / population_OUT
spike_average_matrix = np.reshape(spike_average.repeat(population_OUT), (num_count, population_OUT))
deviation = spike_counter - spike_average_matrix
deviation_2 = np.square(deviation)
standard_deviation = np.sum(deviation_2, axis = 1) 
print('average standard_deviation: ' + str(np.mean(standard_deviation)))
np.save(iteration_folder + '/spike_counter' + '_' + str(population_OUT) + '_' + str(number_iteration) + '.npy', spike_counter)
np.save(iteration_folder + '/spike_standard_deviation' + '_' + str(population_OUT) + '_' + str(number_iteration) + '.npy', standard_deviation)

